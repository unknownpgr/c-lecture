# CPU에서 버스(Bus)의 동작 방식 및 메모리/디스크 접근 예시

## 1. 버스(Bus)의 정의 및 목적

버스(Bus)는 컴퓨터 내의 여러 하드웨어 구성 요소들 간의 데이터, 주소, 제어 신호를 전달하는 공통 통신 경로이다. CPU, 메모리, 입출력 장치 등의 장치는 버스를 통해 상호 통신을 수행한다.

## 2. 버스의 주요 구성 요소

### 2.1 데이터 버스 (Data Bus)

- **기능**: 실제 데이터를 전송한다.
- 양방향 버스로, CPU에서 메모리로, 또는 메모리에서 CPU로 데이터를 보낼 수 있음.
- 예: CPU가 연산 결과를 메모리에 저장하거나, 메모리에서 데이터를 읽어올 때 사용.

### 2.2 주소 버스 (Address Bus)

- **기능**: 데이터가 어디에서 오고 어디로 가야 하는지를 지정하는 주소 정보를 전달한다.
- 일반적으로 단방향 버스이며, CPU가 주소를 외부 장치로 보낸다.
- 주소의 비트 수가 많을수록 접근 가능한 메모리 용량이 큼.

### 2.3 제어 버스 (Control Bus)

- **기능**: 동기화 및 제어 신호를 전달한다.
- 예: 읽기(Read), 쓰기(Write), 인터럽트(Interrupt), 버스 요청(Bus Request) 등의 신호 포함.
- CPU와 주변 장치 간의 동작을 조정하고 상태를 모니터링함.

## 3. 버스의 동작 방식

### 3.1 CPU가 메모리에 접근할 때

1. **주소 지정**: CPU는 원하는 메모리 주소를 주소 버스를 통해 전달.
2. **제어 신호 전송**: CPU는 제어 버스를 통해 "읽기(Read)" 또는 "쓰기(Write)" 신호를 전송.
3. **데이터 전송**:
   - 읽기일 경우: 해당 주소에 저장된 데이터가 메모리로부터 데이터 버스를 통해 CPU로 이동.
   - 쓰기일 경우: CPU가 전달하고자 하는 데이터를 데이터 버스를 통해 메모리로 전송.
4. **작업 완료 신호**: 메모리는 작업 완료를 나타내는 신호를 다시 제어 버스를 통해 CPU에 전달.

예시:  
프로그램 실행 중, CPU가 변수 `x`의 값을 읽기 위해 주소 `0x00401000`에 접근한다고 가정.

- CPU는 주소 버스를 통해 `0x00401000`을 보냄.
- 제어 버스를 통해 "Read" 신호를 보냄.
- 메모리는 해당 주소의 데이터를 데이터 버스를 통해 CPU에 전달.
- CPU는 데이터를 레지스터에 저장하고 연산을 계속 진행.

### 3.2 CPU가 디스크(예: SSD 또는 HDD)에 접근할 때

디스크는 CPU가 직접 접근하지 않고, 입출력 컨트롤러(I/O Controller)를 통해 간접적으로 제어된다. 이는 속도 차이 및 인터페이스 차이 때문이다.

1. **명령어 준비**: CPU는 디스크 컨트롤러에 명령을 전달 (예: "파일 A를 읽어라").
2. **주소 및 명령어 전송**: CPU는 디스크 주소(논리 블록 주소 등)를 주소 버스를 통해 전달하고, 명령어는 데이터 버스를 통해 전달.
3. **제어 신호 전송**: 제어 버스를 통해 I/O 작업을 시작하라는 신호를 보냄.
4. **I/O 컨트롤러 동작**:
   - 디스크 장치가 요청을 처리하고, 데이터를 메모리로 직접 전송 (DMA 사용 시).
5. **데이터 전송**:
   - DMA(Direct Memory Access) 방식: 디스크에서 메모리로 직접 데이터가 이동하고, 완료되면 CPU에 인터럽트로 알림.
   - CPU가 직접 데이터를 받는 경우도 있으나, 일반적으로는 DMA 사용.
6. **인터럽트 처리**: 디스크 작업 완료 후, 인터럽트 신호를 통해 CPU에 알림.

예시:  
사용자가 문서 파일을 열면 운영체제가 해당 파일의 디스크 위치를 파악하고,

- CPU는 디스크 컨트롤러에 파일 블록 번호를 전송.
- 컨트롤러는 디스크로부터 데이터를 읽어 RAM으로 전송.
- CPU는 디스크 접근이 완료되면 해당 데이터를 처리.

## 4. 버스 아비트레이션 (Bus Arbitration)

버스는 여러 장치가 동시에 접근을 시도할 수 있기 때문에, 충돌을 방지하고 일관성 있는 처리를 위해 **버스 아비트레이션(Bus Arbitration)**이 필요하다. 이는 여러 장치가 동시에 버스 접근을 요청할 경우, 어느 장치가 먼저 사용권을 가지는지를 결정하는 과정이다.

### 4.1 아비트레이션의 목적

- 버스 충돌 방지
- 자원의 공정하고 효율적인 분배
- 시스템 안정성과 신뢰성 확보

### 4.2 아비트레이션 방식

#### 1) 중앙 집중형 아비트레이션 (Centralized Arbitration)

- **중앙 제어 장치**가 모든 버스 요청을 관리.
- 우선순위 방식(Priority-based), 순환 방식(Round Robin) 등으로 구현.
- 예: 마스터 장치가 요청을 받아 순서대로 처리.

#### 2) 분산형 아비트레이션 (Distributed Arbitration)

- 각 장치가 자체적으로 아비트레이션을 수행.
- 충돌 해결을 위해 협상 프로토콜(예: 선점, 충돌 감지 등)을 사용.
- 더 복잡하지만, 확장성과 유연성이 높음.

### 4.3 아비트레이션 우선순위 방식 예시

- **고정 우선순위(Fixed Priority)**: 항상 특정 장치가 우선권 가짐.
- **순환 우선순위(Round Robin)**: 요청 순서를 순환적으로 변경.
- **동적 우선순위(Dynamic Priority)**: 현재 시스템 상황에 따라 우선순위 변경.

## 5. 버스의 종류 (구조 기준 분류)

### 5.1 시스템 버스 (System Bus)

- CPU, 메모리, I/O 장치가 공유하는 공통 버스.
- 고전적인 구조이나 병목 현상이 발생할 수 있음.

### 5.2 전용 버스 (Dedicated Bus)

- 특정 장치와만 연결된 전용 버스.
- 예: GPU 전용 버스(PCIe), 메모리 전용 버스(DDR).

### 5.3 내부 버스 vs 외부 버스

- **내부 버스 (Internal Bus)**: CPU 내부의 구성 요소 간 연결.
- **외부 버스 (External Bus)**: CPU와 외부 장치(메모리, I/O 등) 간의 연결.

## 6. 성능 고려 사항

- **버스 폭 (Bus Width)**: 한 번에 전송할 수 있는 데이터의 비트 수. 버스 폭이 클수록 전송 속도 증가.
- **버스 속도 (Bus Speed)**: 클럭 주파수에 따라 전송 속도 결정.
- **병렬성 및 대역폭**: 멀티채널 버스, 고속 인터커넥트(예: PCIe, QPI) 도입으로 처리량 증가 가능.

## 7. 요약

| 구분        | 메모리 접근                       | 디스크 접근                           |
| ----------- | --------------------------------- | ------------------------------------- |
| 주요 경로   | 주소/데이터/제어 버스를 통해 직접 | I/O 컨트롤러를 통한 간접 접근         |
| 속도        | 빠름 (나노초 단위)                | 상대적으로 느림 (마이크로초 ~ 밀리초) |
| 사용 기술   | 주소 지정, 캐시, DRAM             | DMA, 인터럽트, 버퍼링                 |
| 데이터 흐름 | CPU ↔ 메모리                      | 디스크 ↔ 메모리 ↔ CPU                 |

위 내용을 통해 CPU에서 버스를 통한 데이터 전송 방식과 메모리, 디스크에 대한 접근 과정, 그리고 장치 간 충돌을 관리하기 위한 아비트레이션 구조를 명확히 이해할 수 있다.
