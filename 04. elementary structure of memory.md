# 가상 메모리(Virtual Memory): 하드웨어 vs 소프트웨어 처리 (리눅스 중심 구현)

## 1. 정의

**가상 메모리(Virtual Memory)** 는 운영체제와 하드웨어가 협력하여 실제 물리 메모리(RAM)보다 더 큰 메모리 공간을 프로세스에 제공하는 메모리 관리 기법이다.  
리눅스에서 가상 메모리는 **프로세스 격리, 메모리 보호, 효율적 자원 활용**을 위해 핵심적으로 사용된다.

리눅스는 이 구조를 다음 두 계층으로 나누어 처리한다:

- **하드웨어 처리 (Hardware Handled)**: MMU, TLB, 주소 변환 등
- **소프트웨어 처리 (커널에 의한 처리)**: 페이지 테이블 구성, 페이지 폴트 처리, 스왑 등

## 2. 하드웨어적 처리 (Hardware Handled)

| 처리 항목                              | 설명                                                                                               |
| -------------------------------------- | -------------------------------------------------------------------------------------------------- |
| **MMU (Memory Management Unit)**       | 가상 주소를 물리 주소로 변환. 리눅스는 MMU를 전제로 설계됨.                                        |
| **주소 변환**                          | 가상 주소 → 페이지 번호 + 오프셋 → 페이지 테이블 → 물리 프레임 주소                                |
| **TLB (Translation Lookaside Buffer)** | MMU 내부 캐시. 리눅스 커널은 TLB 관리를 위해 `flush_tlb_mm`, `flush_tlb_page` 등의 함수 제공.      |
| **페이지 폴트 트리거**                 | 접근한 가상 주소가 매핑되지 않은 경우 MMU가 CPU에 예외(Page Fault)를 발생시킴. 이후 커널이 개입함. |

## 3. 소프트웨어적 처리 (커널 또는 운영체제에 의한 처리)

### 리눅스 커널의 주요 자료구조

| 자료구조         | 설명                                                                 |
| ---------------- | -------------------------------------------------------------------- |
| `mm_struct`      | 프로세스 전체 가상 메모리 공간을 표현                                |
| `vm_area_struct` | 프로세스의 각 메모리 영역(코드, 힙, 스택 등)을 표현                  |
| `page_table`     | 가상 페이지와 물리 페이지 간의 매핑 정보                             |
| `page` 구조체    | 물리 페이지 하나를 나타내며, 스왑 여부, 참조 수, 캐시 여부 등을 관리 |

### 소프트웨어 처리 항목

| 처리 항목                | 설명                                                                                               |
| ------------------------ | -------------------------------------------------------------------------------------------------- |
| **페이지 테이블 관리**   | 리눅스는 다단계 페이지 테이블 사용 (예: 4단계 - PGD, PUD, PMD, PTE).                               |
| **페이지 교체 알고리즘** | 기본적으로 **LRU (Least Recently Used)** 기반. 실제 구현은 `LRU lists` 및 `page reclaim` 메커니즘. |
| **스왑 처리(Swapping)**  | `kswapd` 커널 쓰레드가 메모리가 부족할 때 백그라운드에서 페이지를 스왑 아웃함.                     |
| **페이지 폴트 핸들링**   | `do_page_fault()` 함수가 폴트 예외를 처리. 필요 시 디스크에서 페이지를 적재.                       |
| **가상 주소 공간 할당**  | `mmap()`, `brk()` 시스템 콜을 통해 커널이 가상 주소 영역을 동적으로 할당.                          |
| **보호 및 접근 제어**    | 각 `vm_area_struct`에는 읽기/쓰기/실행 권한이 명시됨. 불법 접근 시 segmentation fault 발생.        |

## 4. 가상 메모리 동작 흐름 예시 (리눅스 중심)

### 예: 프로세스가 주소 `0x00401000`을 읽으려 할 때

1. **하드웨어 처리**

   - CPU는 가상 주소 `0x00401000`을 생성.
   - MMU는 TLB에서 해당 주소를 찾음 (TLB miss 시 페이지 테이블로 이동).
   - 페이지 테이블의 각 단계(PGD → PUD → PMD → PTE)를 통해 물리 주소를 계산.

2. **소프트웨어 처리 (리눅스 커널 개입)**
   - 해당 주소에 매핑이 없거나 페이지가 스왑된 경우, 페이지 폴트 발생.
   - 커널 함수 `do_page_fault()`가 호출되어 `vm_area_struct`에서 해당 영역 검색.
   - 메모리 부족 시 `kswapd`가 스왑 아웃 수행.
   - 필요한 페이지를 디스크에서 로딩 후 페이지 테이블을 갱신.
   - TLB 플러시 후 프로세스 실행 재개.

## 5. 리눅스의 주소 공간 구성 예시

| 영역                | 설명                                            |
| ------------------- | ----------------------------------------------- |
| 코드 영역 (.text)   | 실행 파일의 기계어 코드                         |
| 데이터 영역 (.data) | 초기화된 전역 변수 및 static 변수               |
| BSS 영역 (.bss)     | 초기화되지 않은 전역 변수                       |
| 힙(Heap)            | 동적 메모리 할당 영역 (`malloc`, `brk`, `sbrk`) |
| 스택(Stack)         | 함수 호출, 지역 변수 저장 영역                  |
| mmap 영역           | 파일 매핑, 공유 메모리, 라이브러리 등           |

> 이 각 영역은 하나 이상의 `vm_area_struct`로 표현되며, `mm_struct`에서 이를 링크드 리스트로 관리함.

## 6. 리눅스의 페이지 테이블 구조 (x86-64 기준)

| 레벨                        | 설명             | 비트  |
| --------------------------- | ---------------- | ----- |
| PGD (Page Global Directory) | 최상위 디렉터리  | 39~47 |
| PUD (Page Upper Directory)  | 상위 디렉터리    | 30~38 |
| PMD (Page Middle Directory) | 중간 디렉터리    | 21~29 |
| PTE (Page Table Entry)      | 최종 페이지 항목 | 12~20 |

- 각 엔트리는 `struct page`와 연계되어 실제 물리 페이지를 참조하거나 스왑 정보를 가짐.
- 주소 하위 12비트는 페이지 내 오프셋으로 사용.

## 7. 시각적 요약

### 하드웨어 처리 요약

- 주소 변환: MMU + TLB
- 예외 트리거: 페이지 폴트 인터럽트

### 소프트웨어 처리 요약 (리눅스)

- `mm_struct`, `vm_area_struct`를 기반으로 주소 공간 정의
- 페이지 폴트 시 `do_page_fault()`로 처리
- 페이지 교체는 LRU 기반, `kswapd` 및 직접 회수

## 8. 결론

리눅스에서의 가상 메모리는 하드웨어와 커널의 긴밀한 협업을 통해 동작한다.

- **하드웨어(MMU, TLB)**는 실시간 주소 변환과 성능 최적화를 담당하며,
- **리눅스 커널**은 프로세스 주소 공간의 생성/관리, 페이지 테이블 구성, 스왑 처리, 보호 기능을 포괄적으로 담당한다.

리눅스의 세분화된 자료구조(`mm_struct`, `vm_area_struct`, `page`, `pte`)와 다양한 페이지 교체 정책을 통해 가상 메모리는 안정성과 확장성을 동시에 달성하고 있다.

# 추가: MMU는 하드웨어인데, 커널이 정의한 PGD, PUD 등을 어떻게 사용할 수 있는가?

## 1. 전제: MMU는 물리적 장치, 커널은 소프트웨어

- **MMU (Memory Management Unit)**:

  - 하드웨어로 내장된 메모리 주소 변환 장치
  - 가상 주소 → 물리 주소로 변환
  - 페이지 테이블의 **물리 주소**를 참조

- **PGD, PUD, PMD, PTE**:
  - 리눅스 커널이 **가상 메모리를 계층적으로 관리하기 위해 정의한 소프트웨어 구조**
  - 이 구조들은 **실제로 물리 메모리에 존재하는 페이지 테이블의 내용을 메모리 상에 해석하거나 구성**하는 데 사용됨
  - 각 구조는 다단계 페이지 테이블에서 한 단계를 구성하며, 아키텍처(x86-64, ARM 등)에 따라 다를 수 있음

### 각 계층의 정의

| 이름                            | 설명                                                                 |
| ------------------------------- | -------------------------------------------------------------------- |
| **PGD (Page Global Directory)** | 페이지 테이블의 최상위 계층. 가상 주소의 최상위 비트를 인덱스로 사용 |
| **PUD (Page Upper Directory)**  | PGD 다음 단계로, 일부 아키텍처에서는 생략되기도 함                   |
| **PMD (Page Middle Directory)** | PUD 다음 단계로, 역시 아키텍처에 따라 생략 가능                      |
| **PTE (Page Table Entry)**      | 실제 페이지 프레임(4KB 등)의 물리 주소를 가리키는 항목               |

> 이 구조들은 실제 페이지 테이블 포맷에 맞춰 메모리에 구성되며, MMU는 이들 구조에 직접 관여하지 않음

## 2. MMU가 이해하는 것 vs 커널이 다루는 것

| 주체              | 이해 가능한 것                                    | 설명                                                                                 |
| ----------------- | ------------------------------------------------- | ------------------------------------------------------------------------------------ |
| MMU (하드웨어)    | **물리 주소**에 위치한 페이지 테이블 항목         | 페이지 테이블의 정확한 레이아웃과 포맷은 CPU 아키텍처(예: x86-64, ARM)에 의해 정의됨 |
| 커널 (소프트웨어) | **논리적인 계층(PGD, PUD, PMD, PTE)** 구조로 관리 | 사용자의 가상 주소 공간을 효율적으로 관리하기 위해 추상화된 구조체 사용              |

## 3. 실제 작동 방식

1. **커널은 페이지 테이블을 메모리에 생성**

   - 커널은 `struct mm_struct`, `struct page`, `pgd_t`, `pud_t` 등의 자료구조를 사용하여 페이지 테이블을 메모리에 구성함
   - 이 테이블들은 결국 **연속적인 메모리 공간**(= 실제 RAM 주소 공간)에 저장됨

2. **커널은 CR3 레지스터에 페이지 테이블의 물리 주소를 설정**

   - MMU가 참조할 수 있도록 커널은 최상위 페이지 디렉터리(PGD)의 **물리 주소**를 CPU의 `CR3` 레지스터에 로드함
   - 이 주소부터 MMU는 하드웨어적인 주소 변환을 시작함

3. **MMU는 커널이 구성한 페이지 테이블을 그대로 사용**
   - MMU는 커널이 메모리에 생성한 계층적 페이지 테이블을, 정의된 포맷대로 해석
   - MMU는 `CR3`에 지정된 물리 주소로부터 페이지 테이블 엔트리를 차례대로 탐색하며 주소 변환 수행

## 4. 32bit vs 64bit 시스템에서의 페이지 테이블 구조

### 32bit 시스템 (예: x86)

- 가상 주소 공간: **4GB (2³²)**
- 일반적으로 **2단계 페이지 테이블** 구조 사용
  - **PGD (Page Directory)** → **PTE (Page Table Entry)**
- 각 페이지 테이블 항목은 4바이트
- 각 테이블에는 1024개 항목이 있으며, 4KB 페이지 기준으로 전체 4GB 공간 관리 가능

### 64bit 시스템 (예: x86-64)

- 가상 주소 공간: 최대 **256 TB (2⁴⁸)** (하드웨어적으로 제한됨)
- 기본적으로 **4단계** 구조 사용 (5단계도 옵션으로 존재)
  - **PGD → PUD → PMD → PTE**
- 각 테이블은 512개 항목을 가지며, 각 항목은 8바이트 (4KB 정렬된 페이지 사용)

### 요약 비교

| 항목               | 32bit 시스템 | 64bit 시스템     |
| ------------------ | ------------ | ---------------- |
| 주소 공간 크기     | 4GB          | 수십 TB ~ EB     |
| 페이지 테이블 단계 | 2단계        | 4~5단계          |
| 엔트리 크기        | 4바이트      | 8바이트          |
| 대표 아키텍처      | x86          | x86-64, ARM64 등 |

## 5. 아키텍처 예시: x86-64에서의 페이지 테이블 포맷

### 가상 주소 비트 구성 (4단계 페이징, 48비트 가상 주소)

| 비트 범위 | 계층   | 인덱스 크기 | 설명                          |
| --------- | ------ | ----------- | ----------------------------- |
| [47:39]   | PGD    | 9비트       | Page Global Directory         |
| [38:30]   | PUD    | 9비트       | Page Upper Directory          |
| [29:21]   | PMD    | 9비트       | Page Middle Directory         |
| [20:12]   | PTE    | 9비트       | Page Table Entry              |
| [11:0]    | 오프셋 | 12비트      | 페이지 내 오프셋 (4KB 페이지) |

- 각 테이블에는 **512개 엔트리 (2⁹)**
- 각 엔트리는 **8바이트 (64비트)**
- 총 4단계 탐색을 통해 최종 물리 주소 결정

### PTE (Page Table Entry)의 구조 (x86-64 기준)

| 비트  | 필드                  | 설명                                                   |
| ----- | --------------------- | ------------------------------------------------------ |
| 0     | P (Present)           | 페이지가 존재하는지 여부                               |
| 1     | R/W (Read/Write)      | 쓰기 가능 여부                                         |
| 2     | U/S (User/Supervisor) | 사용자 접근 가능 여부                                  |
| 3     | PWT                   | Page-level write-through                               |
| 4     | PCD                   | Page-level cache disable                               |
| 5     | A (Accessed)          | 접근된 적 있는지                                       |
| 6     | D (Dirty)             | 쓰기된 적 있는지 (PTE가 페이지 프레임을 가리키는 경우) |
| 7     | PAT                   | Page Attribute Table                                   |
| 8     | G (Global)            | 글로벌 페이지 여부 (TLB에 영향)                        |
| 9~11  | Reserved              | 아키텍처에 따라 다름                                   |
| 12~51 | Physical Address      | 페이지 프레임의 물리 주소 상위 비트                    |
| 52~62 | OS 사용 가능          | 커널에서 자유롭게 사용 가능                            |
| 63    | NX (No Execute)       | 실행 금지 플래그 (PAE 사용 시)                         |

## 6. 트리 구조 페이지 테이블의 이점

### 단일(플랫) 페이지 테이블 구조의 한계

- **주소 공간이 크면 테이블이 비효율적으로 큼**
  - 예: 48비트 가상 주소를 4KB 페이지 단위로 관리하려면 2⁴⁸ / 2¹² = 2³⁶ = 약 64GB의 엔트리가 필요함 (각 엔트리 8바이트라면 테이블 크기는 **512GB**)
- **모든 페이지에 대한 매핑 정보를 미리 구성해야 함**
  - 매우 큰 메모리가 필요하고, 실제 사용하지 않는 주소 영역에도 엔트리를 만들어야 함

### 다단계(트리형) 페이지 테이블의 장점

| 항목               | 단일 테이블 | 트리 구조 (다단계)                         |
| ------------------ | ----------- | ------------------------------------------ |
| 메모리 효율        | 매우 낮음   | **매우 높음** (필요한 영역만 테이블 생성)  |
| 확장성             | 제한적      | 매우 유연함                                |
| 초기 메모리 사용량 | 매우 큼     | **작음**                                   |
| 주소 공간 관리     | 비효율적    | 계층화되어 효율적                          |
| 가상 주소 탐색     | 단일 인덱싱 | 계층적 인덱싱 (하드웨어가 최적화되어 빠름) |

- 실제 사용하는 주소 범위에 대해서만 하위 테이블을 할당
- 미사용 영역은 테이블 자체를 만들지 않기 때문에 **공간 절약**이 큼
- 트리 구조는 **희소한(sparse)** 주소 공간에서 특히 유리

## 7. 예시: x86-64 아키텍처에서의 흐름

1. 커널이 `pgd_alloc()`, `p4d_alloc()` 등을 통해 페이지 테이블 구성
2. 구성된 테이블은 메모리에 존재하고, 각 엔트리는 아키텍처 정의에 맞게 포맷됨
3. 커널은 `write_cr3()`를 호출하여 최상위 페이지 테이블의 **물리 주소**를 CPU의 `CR3` 레지스터에 설정
4. 이후 MMU는 페이지 폴트가 발생할 때마다 이 페이지 테이블을 직접 해석함

## 8. 결론

- **MMU는 커널이 만들어 놓은 페이지 테이블을 직접 참조한다.**
- 커널은 페이지 테이블을 메모리에 구조화하고, 그 위치를 MMU에게 알려준다.
- MMU는 소프트웨어 구조체(PGD 등)를 모르는 대신, **물리 메모리 상의 페이지 테이블 포맷을 이해**하고 처리한다.
- 계층적 페이지 테이블(트리 구조)을 사용하면, 대규모 가상 주소 공간을 **메모리 효율적이며 유연하게 관리**할 수 있다.
