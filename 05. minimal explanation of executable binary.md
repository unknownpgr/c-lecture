# Executable Binary

## 1. 정의

ELF(Executable and Linkable Format)는 유닉스(UNIX) 계열 운영체제에서 사용되는 표준 실행 파일 포맷으로, 실행 파일, 목적 파일(Object File), 공유 라이브러리 및 코어 덤프(Core Dump)를 저장하는 데 사용된다.

## 2. 구성 요소

### 1.1 헤더

ELF 헤더는 실행 파일의 전체 구조를 설명하는 메타데이터를 포함한다.

- **Magic Number**: 0x7F, 'E', 'L', 'F'로 구성된 고유 식별자
- **Class**: 32비트(ELF32) 또는 64비트(ELF64) 구분
- **Endianness**: 리틀 엔디안 또는 빅 엔디안 여부
- **Type**: 실행 파일, 목적 파일, 공유 객체 등
- **Machine**: 대상 아키텍처 (예: x86, ARM 등)
- **Entry point address**: 실행 시작 지점의 가상 주소
- **Program Header Table offset**: 프로그램 헤더 테이블의 파일 내 오프셋
- **Section Header Table offset**: 섹션 헤더 테이블의 파일 내 오프셋

### 1.2 프로그램 헤더 테이블

프로그램 헤더 테이블은 실행 파일의 각 세그먼트에 대한 정보를 저장한다. 이는 바이너리가 실행될 때 참조된다.

- **Type**: 세그먼트의 타입 (예: `LOAD`, `DYNAMIC`, `INTERP` 등)
- **Offset**: 세그먼트의 파일 내 오프셋
- **Virtual Address**: 세그먼트의 가상 주소
- **Physical Address**: 세그먼트의 물리 주소
- **File Size**: 세그먼트의 파일 내 크기
- **Memory Size**: 세그먼트의 메모리 내 크기
- **Flags**: 세그먼트의 특성 플래그
- **Alignment**: 세그먼트의 정렬 요구 사항

### 1.3 섹션 헤더 테이블

섹션 헤더 테이블은 실행 파일의 각 섹션에 대한 정보를 저장한다. 섹션은 링킹 등의 과정에서 사용된다.

- **Name**: 섹션의 이름
- **Type**: 섹션의 타입 (예: `PROGBITS`, `SYMTAB`, `STRTAB` 등)
- **Flags**: 섹션의 특성 플래그
- **Address**: 섹션의 가상 주소
- **Offset**: 섹션의 파일 내 오프셋
- **Size**: 섹션의 크기

### 1.4 Segment vs Section

| 항목      | 섹션(Section)                          | 세그먼트(Segment)              |
| --------- | -------------------------------------- | ------------------------------ |
| 목적      | 컴파일 및 링킹을 위한 논리적 단위      | 실행을 위한 메모리 배치 단위   |
| 참조 시점 | 컴파일 및 링크 타임                    | 로드 타임 (실행 시점)          |
| 사용 주체 | 링커, 디버거                           | 운영체제 커널 (로더)           |
| 예시      | `.text`, `.data`, `.bss`, `.symtab` 등 | `LOAD`, `DYNAMIC`, `INTERP` 등 |

## 2. 구조 확인

xxd는 바이너리 파일을 16진수로 출력하는 명령어다.

```bash
xxd <filename>
```

readelf는 ELF 파일의 내용을 읽고 분석하는 명령어다. 이는 바이너리의 구조를 이해하고 디버깅하는 데 도움을 준다.

```bash
readelf -h <filename> # 헤더 정보
readelf -l <filename> # 프로그램 헤더 테이블
readelf -S <filename> # 섹션 헤더 테이블
```

## 3. Compile

프로그램의 빌드 과정은 아래와 같은 단계로 나뉜다.

- 전처리
- 컴파일
- 어셈블
- 링킹

일반적으로 빌드를 할 때는 `gcc`등의 유틸리티를 이용하여 소스코드로부터 곧바로 바이너리를 얻는다. 그러나 `gcc`는 실제로는 `cpp`(전처리기), `cc`(컴파일러), `as`(어셈블러), `ld`(링커)와 같은 독립적인 프로그램들을 사용하는 프론트엔드이며, 실제 작업은 이와 같은 세부적인 단계의 조합으로 이루어진다.

## 4. Relocation

**Relocation**은 프로그램의 컴파일 및 링크 과정에서 생성된 **기호(Symbol)** 들의 실제 메모리 주소를 결정하고 수정하는 과정이다. 이는 프로그램을 실행 가능한 형태로 만들기 위해 반드시 수행되어야 하며, 링커와 로더에 의해 이루어진다.

기계어 명령어에는 전역 변수나 함수 등의 기호를 참조하는 코드가 포함되어 있는데, 이들은 컴파일 시점에 정확한 주소를 알 수 없기 때문에 임시 주소(예: 상대 주소 또는 기호 이름)로 기록된다. 이 주소들을 실행 가능한 실제 주소로 바꾸는 작업이 relocation이다.

Relocation은 **정적 링크(Static Linking)** 와 **동적 링크(Dynamic Linking)** 환경에서 각각 다른 방식으로 수행된다.

### Static Linking

- 정적 링크는 링커(`ld`)가 여러 개의 오브젝트 파일(`.o`)과 정적 라이브러리(`.a`)를 결합하여 하나의 실행 파일을 만드는 과정이다.
- 각 오브젝트 파일은 자신이 사용하는 외부 기호(예: 다른 파일의 함수 또는 전역 변수)의 정의를 포함하지 않기 때문에, 링커는 전체 파일들을 통합하여 기호들의 실제 주소를 계산한다.
- 링커는 이 과정에서 다음 작업을 수행한다:

  - 각 오브젝트 파일의 섹션(텍스트, 데이터 등)을 메모리 상에 배치
  - 기호 테이블을 기반으로 참조 기호의 주소를 결정
  - 각 참조 지점에 실제 주소를 반영하여 코드와 데이터를 수정

- 결과적으로, 정적으로 링크된 실행 파일은 외부 참조 없이 독립적으로 실행이 가능하다.

### Dynamic Linking

- 동적 링크는 실행 시점(Run-time)에 필요한 라이브러리를 메모리에 로드하고, 해당 라이브러리의 함수 및 데이터 주소를 결정하는 방식이다.
- 실행 파일은 컴파일 및 링크 시점에 동적 라이브러리를 참조하되, 실제 기호의 주소는 런타임까지 미정이다.
- 실행 시 운영체제의 로더가 다음과 같은 작업을 수행한다:

  - 실행 파일의 요청에 따라 공유 라이브러리(`.so`)를 메모리에 로드
  - 공유 라이브러리 간의 기호 충돌을 해결하고, 실제 주소를 계산
  - 실행 파일 내의 필요한 주소 테이블(예: GOT(Global Offset Table), PLT(Procedure Linkage Table))을 수정하여 올바른 함수와 변수 주소를 연결

- 이러한 작업은 일반적으로 `ld-linux.so`, `ld.so` 와 같은 **동적 링커(Dynamic Linker/Loader)** 에 의해 수행된다.
- 이를 통해 실행 파일은 라이브러리를 공유하고 메모리 사용량을 줄이며, 업데이트된 라이브러리를 재컴파일 없이 사용할 수 있다.
